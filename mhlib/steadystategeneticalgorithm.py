"""A basic steady-state genetic algorithm."""

from typing import List, Callable
from itertools import cycle
import random

from mhlib.scheduler import Method, Scheduler
from mhlib.settings import get_settings_parser
from mhlib.solution import Solution


parser = get_settings_parser()
parser.add("--mh_ssga_pop_size", type=int, default=100, help='SSGA population size')
parser.add("--mh_ssga_tournament_size", type=int, default=10, help='SSGA tournament size')
parser.add("--mh_ssga_cross_prob", type=int, default=0.1, help='SSGA crossover probability')
parser.add("--mh_ssga_loc_prob", type=int, default=0.1, help='SSGA local improvement probability')


class SteadyStateGeneticAlgorithm(Scheduler):
    """A steady state genetic algorithm.

    During each iteration, one new solution is generated by means
    of crossover and mutation. The new solution
    replaces the worst of the population.

    Attributes
        - sol: solution object, in which final result will be returned
        - meths_ch: list of construction heuristic methods
        - meth_cx: a crossover method
        - meth_mu: a mutation method
        - meth_ls: a local search method
    """

    def __init__(self, sol: Solution, meths_ch: List[Method],
                 meth_cx: Callable[[Solution, Solution], Solution],
                 meth_mu: Method,
                 meth_li: Method,
                 own_settings: dict = None):
        """Initialization.

        :param sol: solution to be improved
        :param meths_ch: list of construction heuristic methods
        :param meth_cx: a crossover method
        :param meth_mu: a mutation method
        :param meth_li: an optional local improvement method
        :param own_settings: optional dictionary with specific settings
        """
        super().__init__(sol, meths_ch + [meth_mu] + [meth_li], own_settings)
        self.meths_ch = meths_ch
        self.meth_cx = meth_cx
        self.meth_mu = meth_mu
        self.meth_ls = meth_li

        self.population: List[Solution] = []

    def selection(self):
        """Tournament selection.

        :return: a solution
        """
        pop = self.population
        k = self.own_settings.mh_ssga_tournament_size

        best = pop[random.randint(1, len(pop)) - 1]

        for i in range(k - 1):
            individual = pop[random.randint(1, len(pop)) - 1]
            if individual.is_better(best):
                best = individual

        return best

    def run(self):
        """Actually performs the construction heuristics followed by the SteadyStateGeneticAlgorithm."""

        population = self.population

        meths_cycle = cycle(self.meths_ch)

        # cycle through construction heuristics to generate population
        # perform all construction heuristics, take best solution
        while len(population) < self.own_settings.mh_ssga_pop_size:
            m = next(meths_cycle)
            sol = self.incumbent.copy()
            res = self.perform_method(m, sol)
            population.append(sol)

            if population[-1].is_better(self.incumbent):
                self.incumbent = population[-1].copy()

            if res.terminate:
                break

        while True:
            # Create a new solution
            p1 = self.selection().copy()

            # Optionally crossover
            if random.random() < self.own_settings.mh_ssga_cross_prob:
                p2 = self.selection().copy()
                p1 = self.meth_cx(p1, p2)

            # Mutation
            res = self.perform_method(self.meth_mu, p1)

            if res.terminate:
                break

            # Optionally locally improve
            if self.meth_ls and random.random() < self.own_settings.mh_ssga_loc_prob:
                res = self.perform_method(self.meth_ls, p1)

                if res.terminate:
                    break

            # Replace in population
            worst = 0
            for idx, p in enumerate(population):
                if population[worst].is_better(p):
                    worst = idx

            population[worst].copy_from(p1)

            # Update best solution
            if p1.is_better(self.incumbent):
                self.incumbent = p1
