"""A steady-state genetic algorithm

"""

from typing import List
from itertools import cycle

from mhlib.scheduler import Method, Scheduler
from mhlib.settings import get_settings_parser
from mhlib.solution import Solution

import random

parser = get_settings_parser()
parser.add("--mh_ssga_pop_size", type=int, default=100, help='SSGA population size')
parser.add("--mh_ssga_tournament_size", type=int, default=10, help='SSGA tournament size')
parser.add("--mh_ssga_cross_prob", type=int, default=0.1, help='SSGA crossover probability')
parser.add("--mh_ssga_loc_prob", type=int, default=0.1, help='SSGA local improvement probability')


class SSGA(Scheduler):
    """A steady state genetic algorithm.
    During each generation, only one new solution is generated by means
    of variation operators (crossover and mutation). The new solution
    replaces an existing solution (e.g. the worst of the population).

    Attributes
        - sol: solution object, in which final result will be returned
        - meths_ch: list of construction heuristic methods
        - meth_cx: a crossover method
        - meth_mu: a mutation method
        - meth_ls: a local search method
    """

    def __init__(self, sol: Solution, meths_ch: List[Method],
                 meth_cx,
                 meth_mu: Method,
                 meth_ls: Method,
                 own_settings: dict = None):
        """Initialization.

        :param sol: solution to be improved
        :param meths_ch: list of construction heuristic methods
        :param meth_cx: a crossover method
        :param meth_mu: a mutation method
        :param meth_ls: a local search method
        :param own_settings: optional dictionary with specific settings
        """
        super().__init__(sol, meths_ch + [meth_mu] + [meth_ls], own_settings)
        self.meths_ch = meths_ch
        self.meth_cx = meth_cx
        self.meth_mu = meth_mu
        self.meth_ls = meth_ls

        self.population: List[Solution] = []

    def selection(self):
        """Tournament selection.

        :return: a solution
        """
        pop = self.population
        k = self.own_settings.mh_ssga_tournament_size

        best = pop[random.randint(1, len(pop)) - 1]

        for i in range(k - 1):
            individual = pop[random.randint(1, len(pop)) - 1]
            if individual.is_better(best):
                best = individual

        return best

    def run(self):
        """Actually performs the construction heuristics followed by the SSGA."""

        population = self.population

        meths_cycle = cycle(self.meths_ch)

        # cycle through construction heuristics to generate population
        # perform all construction heuristics, take best solution
        while len(population) < self.own_settings.mh_ssga_pop_size:
            m = next(meths_cycle)
            sol = self.incumbent.copy()
            res = self.perform_method(m, sol)
            population.append(sol)

            if population[-1].is_better(self.incumbent):
                self.incumbent = population[-1].copy()

            if res.terminate:
                break

        while True:
            # Create a new solution
            p1 = self.selection().copy()

            # Optionally crossover
            if random.random() < self.own_settings.mh_ssga_cross_prob:
                p2 = self.selection().copy()
                p1 = self.meth_cx(p1, p2)

            # Mutation
            res = self.perform_method(self.meth_mu, p1)

            if res.terminate:
                break

            # Optionally locally improve
            if random.random() < self.own_settings.mh_ssga_loc_prob:
                res = self.perform_method(self.meth_ls, p1)

                if res.terminate:
                    break

            # Replace in population
            worst = 0
            for idx, p in enumerate(population):
                if population[worst].is_better(p):
                    worst = idx

            population[worst].copy_from(p1)

            # Update best solution
            if p1.is_better(self.incumbent):
                self.incumbent = p1
